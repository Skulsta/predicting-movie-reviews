from pathlib import Path
from collections import Counter
from itertools import dropwhile
import re
import pickle

stop_words = Path('aclImdb/stopwords.txt').read_text()

def prepare_data(directory):
    data = []
    dirpath = Path(directory)
    assert(dirpath.is_dir())
    for x in dirpath.iterdir():
        if x.is_file() and re.search('^\d+?_([1-9]|10)\.txt$', x.name):
            data.append(re.split('\s+', re.sub(r'[^\w\s]','',Path(x).read_text(errors='ignore')).lower()))
        elif x.is_dir():
            data.extend(prepare_data(x))
    return data


def remove_stopwords(counter):
    for word in list(counter):
        if word in stop_words:
            del counter[word]


def make_counter(reviews):
    result = []
    for review in reviews:
        for word in review:
            if word not in stop_words:
                result.append(word)
    return Counter(result)


def prepare_input(review):
    result = []
    for word in review:
        if word not in stop_words and word in all_train_data:
            result.append(word)
    return result


def remove_least_common(counter):
    for key, count in dropwhile(lambda key_count: key_count[1] >= 30, counter.most_common()):
        del counter[key]
    return counter


# Data sets split into Counters. Least common words are removed.
all_train_data = remove_least_common(make_counter(prepare_data('aclImdb/train')))
train_neg = remove_least_common(make_counter(prepare_data('aclImdb/train/neg')))
train_pos = remove_least_common(make_counter(prepare_data('aclImdb/train/pos')))

neg_num_of_words = sum(train_neg.values())
pos_num_of_words = sum(train_pos.values())
# words_and_weights = dict()

pos_word_weights = dict()
neg_word_weights = dict()

def make_word_weights():
    for word in all_train_data.keys():
        if word in train_pos:
            pos_word_weights[word] = (train_pos.get(word) /
                    pos_num_of_words)
        if word in train_neg:
            neg_word_weights[word] = (train_neg.get(word) /
                    neg_num_of_words)


# make_word_weights()

def save_obj(obj, name):
    with open('word_weights/' + name + '.pkl', 'wb') as f:
        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)


def load_obj(name):
    with open('word_weights/' + name + '.pkl', 'rb') as f:
        return pickle.load(f)


# save_obj(pos_word_weights, 'pos_word_weights')
# save_obj(neg_word_weights, 'neg_word_weights')

pos_word_weights = load_obj('pos_word_weights')
neg_word_weights = load_obj('neg_word_weights')


def get_prediction(review):
    input_counter = prepare_input(review)
    alpha = 1
    product_of_pos = 1
    product_of_neg = 1
    for word in input_counter:
        if word in pos_word_weights and word in neg_word_weights:
            product_of_pos *= (pos_word_weights.get(word, 0) + alpha)
            product_of_neg *= (neg_word_weights.get(word, 0) + alpha)
    prediction = ((product_of_pos) /
            ((product_of_pos) + (product_of_neg)))
    return prediction


def calculate_error():
    neg_test_reviews = prepare_data('aclImdb/test/neg')
    pos_test_reviews = prepare_data('aclImdb/test/pos')
    correct_neg_prediction = 0
    correct_pos_prediction = 0

    for review in neg_test_reviews:
        if (get_prediction(review) < 0.5):
            correct_neg_prediction += 1

    for review in pos_test_reviews:
        if (get_prediction(review) > 0.5):
             correct_pos_prediction += 1

    print("------------")
    print("Predicted correctly on: " + str(correct_neg_prediction) + " of " +
            str(len(neg_test_reviews)) + " negative reviews")
    print("Error rate for negative reviews: " + str(correct_neg_prediction /
        len(neg_test_reviews)))
    print("Predicted correctly on: " + str(correct_pos_prediction) + " of " +
            str(len(pos_test_reviews)) + " positive reviews")
    print("Error rate for positive reviews: " + str(correct_pos_prediction /
        len(pos_test_reviews)))
    return ((correct_neg_prediction + correct_pos_prediction) /
            (len(neg_test_reviews) +
            len(pos_test_reviews)))


print("Calculating test reviews ...")
print(calculate_error())
